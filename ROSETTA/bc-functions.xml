# These are the functions I convert into various languages. The body
# *must* be in Mathematica's "FullForm" (not InputForm or FortranForm
# or CForm)

# fields:

# body: the body of the function in Mathematica's FullForm
# nice: a "prettyprint" version of function (not LaTeX)
# desc: a description of the function
# vars: the named arguments to the function, as a comma separated list

# TODO: test harness, but probably not part of function

# macros:

# <LANG>: the language into which the function is being translated

<function name="testing0002">
<nice>{sqrt(cos(y) + sin(x)), sqrt(cos(x) + sin(y))}</nice>
<vars>x,y</vars>
<desc>A simple test to show how functions can be converted to langs</desc>
# TODO: manually editing Rational[1,2] to have decimals = bad!
<body>

List[Power[Plus[Cos[y], Sin[x]], Rational[1.0, 2.0]],
Power[Plus[Cos[x], Sin[y]], Rational[1.0, 2.0]]]

</body>
</function>

# below does NOT work with Perl, returning scalar vs array (may be pdef issue)
<function name="testing0003">
<nice>cos(x)^2+cos(y)^2</nice>
<vars>x,y</vars>
<desc>Test with single value return</desc>
<body>
Plus[Cos[Power[x, 2]], Cos[Power[y, 2]]]
</body>
</function>

# attempt to define a dictionary (using "key: val", not true XML)

<dictionary name="constants">

# below is in km (need to make that clear somewhere or be consistent)
earthMeanRadius: 6378.1370
earthPolarRadius: 6356.7523

# sort of ugly to define this, since some langs already do
# TODO: how long can this be w/o breaking languages
# TODO: is typing an issue here?
pi: 3.1415926535897932385
e: 2.7182818284590452354

</dictionary>

# convert hours/degrees to radians by multiplying

<dictionary name="radians">

degrees: 0.017453292519943295769
hours: 0.26179938779914943654

</dictionary>

# convert time to Unix time using affine transformations
# affine first then multip

<dictionary name="unixtime">

jdAffine: -2440587.5
jdMultip: 86400

# days since J2000

j2000daysAffine: 10957.5
j2000daysMultip: 86400

</dictionary>

# convert lengths to meters by multiplying

<dictionary name="meters">

km: 0.001

# can't use 'm' here, since 'm' means meter itself
miles: 0.00062137119223733396962


</dictionary>

<function name="shadowlandlat">
<nice>no clean format</nice>
<vars>h,r,theta,az,lat,lon</vars>
<desc>Gives the latitude of where a shadow lands per bc-fuji.m</desc>
<body>
ArcTan[Power[Plus[Power[Plus[Times[Power[Cos[theta], 2], Plus[Times[Cos[lon], Sin[az], Sin[lat]], Times[Cos[az], Sin[lon]]], Plus[Power[Plus[Times[-1, Power[Plus[h, r], 2]], Times[Power[r, 2], Power[Sec[theta], 2]]], Rational[1, 2]], Times[-1, Plus[h, r], Tan[theta]]]], Times[Cos[lat], Cos[lon], Power[Plus[Power[r, 2], Times[-1, Power[Cos[theta], 4], Power[Plus[Power[Plus[Times[-1, Power[Plus[h, r], 2]], Times[Power[r, 2], Power[Sec[theta], 2]]], Rational[1, 2]], Times[-1, Plus[h, r], Tan[theta]]], 2]]], Rational[1, 2]]]], 2], Power[Plus[Times[Power[Cos[theta], 2], Plus[Times[Cos[az], Cos[lon]], Times[-1, Sin[az], Sin[lat], Sin[lon]]], Plus[Times[-1, Power[Plus[Times[-1, Power[Plus[h, r], 2]], Times[Power[r, 2], Power[Sec[theta], 2]]], Rational[1, 2]]], Times[Plus[h, r], Tan[theta]]]], Times[Cos[lat], Sin[lon], Power[Plus[Power[r, 2], Times[-1, Power[Cos[theta], 4], Power[Plus[Power[Plus[Times[-1, Power[Plus[h, r], 2]], Times[Power[r, 2], Power[Sec[theta], 2]]], Rational[1, 2]], Times[-1, Plus[h, r], Tan[theta]]], 2]]], Rational[1, 2]]]], 2]], Rational[1, 2]], Plus[Times[Cos[lat], Power[Cos[theta], 2], Sin[az], Plus[Times[-1, Power[Plus[Times[-1, Power[Plus[h, r], 2]], Times[Power[r, 2], Power[Sec[theta], 2]]], Rational[1, 2]]], Times[Plus[h, r], Tan[theta]]]], Times[Sin[lat], Power[Plus[Power[r, 2], Times[-1, Power[Cos[theta], 4], Power[Plus[Power[Plus[Times[-1, Power[Plus[h, r], 2]], Times[Power[r, 2], Power[Sec[theta], 2]]], Rational[1, 2]], Times[-1, Plus[h, r], Tan[theta]]], 2]]], Rational[1, 2]]]]]
</body>
</function>
